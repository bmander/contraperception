<html>
<head>
  <script src="processing.js"></script>
</head>
<h1>Contra Perception</h1>
<p><canvas id="canvas1" width="400" height="400"></canvas></p>

<script id="script1" type="text/javascript">

    var dancer;
    var centerX;
    var centerY;
    var maxArmLength;
    var theta = 0;
    var set;
    var d1,d2,d3,d4;

    var bpm=115;

    var beatlen = 60/bpm;

    function Dancer(x,y,facing,lead,active,P) {
        this.SIZE = 10;
        this.POINTER = 12;
        this.s = new P.PVector(x,y);

        this.magv = 0;
        this.target = null;

        this.magomega = 0;
        this.axis = null;

        this.facing = facing;

        this.lead = lead;
        this.active = active;

        this.lastincr=null;
        this.nextstop=null;
        this.angnextstop=null;

        this.P = P;

        this.script = [];
        this.stack = [];
    }
    Dancer.prototype.setpos = function(x,y){
        this.s = new this.P.PVector(x,y);
    }
    Dancer.prototype.incr = function() {
        // start the next move if ready
        if(this.target==null) {
            if(this.script.length>0 && this.script[0].type=='move'){
                nextmove = this.script.shift();
                this.move(nextmove.pos,nextmove.beats);
            }
        }

        if(this.lastincr==null) {
            this.lastincr = this.P.millis();
            return;
        }         
       
        now = this.P.millis();
        dt = (now-this.lastincr)/1000; //convert millis to seconds

        if(this.target!=null){

            dir = this.P.PVector.sub(this.target,this.s);
            dir.normalize();
            v = this.P.PVector.mult(dir,this.magv);

            ds = this.P.PVector.mult(v,dt)
            this.s.add( ds );
        }

        if(this.axis!=null) {
            dtheta = this.magomega*dt;
            // take the vector from axis to position
            radius = this.P.PVector.sub(this.s, this.axis);
            // rotate it by dtheta
            xp = radius.x*Math.cos(dtheta)-radius.y*Math.sin(dtheta);
            yp = radius.x*Math.sin(dtheta)+radius.y*Math.cos(dtheta);
            radiusp = new this.P.PVector(xp,yp);
            // put the dancer at the sum of the axis and the resultant vector
            this.s = this.P.PVector.add(this.axis,radiusp);
        }

        this.lastincr = now;

        if(now>this.nextstop){
            this.magv=0;
            this.target=null;
        }
        if(now>this.nextangstop){
            this.magomega=0;
            this.axis=null;
        }
    }
    Dancer.prototype.move = function(pos,beats){
        dt = beats*beatlen;
        ds = this.P.PVector.sub(pos,
                                this.s);
        this.magv = ds.mag()/dt;
        this.target = pos;

        this.nextstop = this.P.millis()+dt*1000;
    }
    Dancer.prototype.enqueue_move = function(pos,beats) {
        this.script.push( {'type':'move', 'pos':pos,'beats':beats} )
    }
    Dancer.prototype.draw = function() {
        this.P.stroke(0,0,0);
        this.P.strokeWeight(1.5);
        this.P.line(this.s.x, 
                        this.s.y, 
                        this.s.x+this.P.cos(this.facing)*this.POINTER,
                        this.s.y-this.P.sin(this.facing)*this.POINTER);

        this.P.strokeWeight(1);
        if(this.lead) {
            this.P.fill(128,128,128);
        } else {
            this.P.fill(255,255,255);
        }
        this.P.ellipse( this.s.x, this.s.y, this.SIZE, this.SIZE );
        if(this.active) {
            this.P.fill(0,0,0,0);
            this.P.ellipse(this.s.x,this.s.y,this.SIZE+6,this.SIZE+6);
        }
    }
    Dancer.prototype.face = function(dancer) {
        vv = this.P.PVector.sub(dancer.s,this.s)
        this.facing = Math.atan2(vv.y,vv.x);
    }
    Dancer.prototype.swing = function(dancer,beats){
        //draw together
        //orbit some number of times
        //end up with the follow on the right
    }
    Dancer.prototype.balance = function(dancer, beats) {
        origpos = new this.P.PVector(this.s.x,this.s.y);
        this.step_forward( dancer, beats/2 );
        this.step_away( origpos, beats/2 );
    }
    Dancer.prototype.step_forward= function(dancer, beats) {
        ds = this.P.PVector.sub(dancer.s,this.s)
        ds.div(4)
        sp = this.P.PVector.add(this.s,ds)

        this.enqueue_move(sp, beats/2);
        this.enqueue_move(sp, beats/2);
    }
    Dancer.prototype.step_away = function(pos, beats) {
        this.enqueue_move(pos, beats/2); 
        this.enqueue_move(pos, beats/2);
    }

    function Set(x,y,width,activelead,activefollow,inactivelead,inactivefollow) {
        this.x=x;
        this.y=y;
        this.width=width;

        activelead.setpos( this.x-width/2, this.y-width/2 );
        activelead.active = true;
        activelead.lead = true;

        activefollow.setpos( this.x-width/2, this.y+width/2 );
        activefollow.active = true;
        activefollow.lead = false;

        inactivelead.setpos(this.x+width/2, this.y+width/2 );
        inactivelead.active = false;
        inactivelead.lead = true;

        inactivefollow.setpos(this.x+width/2, this.y-width/2);
        inactivefollow.active = false;
        inactivefollow.lead = false;

        this.activelead = activelead;
        this.activefollow = activefollow;
        this.inactivelead = inactivelead;
        this.inactivefollow = inactivefollow;
    }
    Set.prototype.draw = function() {
        this.activelead.draw();
        this.activefollow.draw();
        this.inactivelead.draw();
        this.inactivefollow.draw();
    }
    Set.prototype.neighbor = function() {
        this.activelead.face( this.inactivefollow );
        this.inactivefollow.face( this.activelead );
        this.activefollow.face( this.inactivelead );
        this.inactivelead.face( this.activefollow );
    }
    Set.prototype.neighbor_balance = function(beats) {
        this.neighbor();

        this.activelead.balance(this.inactivefollow, beats);
        this.inactivefollow.balance(this.activelead, beats);
        this.activefollow.balance(this.inactivelead, beats);
        this.inactivelead.balance(this.activefollow, beats);
    }

    // Simple way to attach js code to the canvas is by using a function
    function sketchProc(processing) {
        processing.setup = function() {
            processing.size( 400,400 );

            centerX = processing.width / 2, centerY = processing.height / 2;

            d1 = new Dancer(0,0,0,false,false,processing);
            d2 = new Dancer(0,0,0,false,false,processing);
            d3 = new Dancer(0,0,0,false,false,processing);
            d4 = new Dancer(0,0,0,false,false,processing);

            set = new Set(centerX, centerY, 30, d1, d2, d3, d4);
        }

      // Override draw function, by default it will be called 60 times per second
      processing.draw = function() {
        // erase background
        processing.background(224);

        d1.incr();
        d2.incr();
        d3.incr();
        d4.incr();

        set.draw();
      };
      
    }

    var canvas = document.getElementById("canvas1");

    // attaching the sketchProc function to the canvas
    var p = new Processing(canvas, sketchProc);

    // p.exit(); to detach it
</script>

<div style="height:0px;width:0px;overflow:hidden;"></div>


